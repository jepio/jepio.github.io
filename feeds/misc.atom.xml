<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom"><title>Jepio's blog</title><link href="//jepio.github.io/" rel="alternate"></link><link href="//jepio.github.io/feeds/misc.atom.xml" rel="self"></link><id>//jepio.github.io/</id><updated>2015-10-19T12:15:00+02:00</updated><entry><title>playing with cp</title><link href="//jepio.github.io/playing-with-cp.html" rel="alternate"></link><updated>2015-10-19T12:15:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-10-19:playing-with-cp.html</id><summary type="html">&lt;p&gt;BTRFS breathes new air into the old &lt;code&gt;cp&lt;/code&gt; command. Suddenly it can be used to
create instantaneous copy-on-write (CoW) snapshots of single files via &lt;code&gt;cp
--reflink&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;When you want to convert a folder to a subvolume, you are best of with the
following commands:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;# mv folder folder_old
# btrfs su create ./folder
# cp -a --reflink ./folder_old/. folder
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;If you want to disable data CoW (as with &lt;code&gt;nodatacow&lt;/code&gt; mount option [but which
isn't that useful because it applies to the whole btrfs volume]) on single
files you need apply the xattr +C to it, and defrag, or simply &lt;code&gt;cp&lt;/code&gt; it (if it's
a folder best to use &lt;code&gt;cp -a folder/. dest&lt;/code&gt;).&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;chattr +C file
&lt;span class="nv"&gt;$ &lt;/span&gt;btrfs &lt;span class="k"&gt;fi&lt;/span&gt; defrag file &lt;span class="c"&gt;# or&lt;/span&gt;
&lt;span class="nv"&gt;$ &lt;/span&gt;cp --reflink&lt;span class="o"&gt;=&lt;/span&gt;never file file.new &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; mv file.new file
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;And there you have it: cp is suddenly much more useful.&lt;/p&gt;</summary></entry><entry><title>Late to the (SystemD)inner party</title><link href="//jepio.github.io/late-to-the-systemdinner-party.html" rel="alternate"></link><updated>2015-09-21T10:28:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-09-21:late-to-the-systemdinner-party.html</id><summary type="html">&lt;p&gt;I may be coming late to the SystemD bashing party, but I'd just like to say
that I disagree with all of the opponents of this init system. It makes sense
to have all of the basic components in one place (journal, basic networking),
it does speed up booting and as far as I know has a solid code base.&lt;/p&gt;
&lt;p&gt;Feeling your &lt;em&gt;unix philosophy&lt;/em&gt; has been violated? How has &lt;em&gt;it&lt;/em&gt; benefited you
in this case before? The init system is not something that you run in your
shell where piping, composition and all this nice stuff makes sense. It runs
before you have a chance to mess with the system and for all you should care it
should not get in the way.&lt;/p&gt;
&lt;p&gt;Systemd makes administering systems easier, my knowledge is more portable
thanks to it and the wide adoption. This also means that there probably are
more people who like it (or don't give a fuck) than those that criticize it. So
deal with it.&lt;/p&gt;</summary></entry><entry><title>Vmstat rocks</title><link href="//jepio.github.io/vmstat-rocks.html" rel="alternate"></link><updated>2015-09-15T17:22:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-09-15:vmstat-rocks.html</id><summary type="html">&lt;p&gt;Something I find myself doing constantly is monitoring the performance of my
machines. CPU usage, VM (virtual memory) usage and the likes.&lt;/p&gt;
&lt;p&gt;The goto-application for this purpose is top. Top is great, and can be used on
linux as well as BSD's, which I have been experimenting with recently, but is a
bit too noisy most of the time. The default color settings of red + yellow make
some items too dark and others too bright so I prefer the uncoloured output.
This still has the downside that you see numbers/text all over the place and it
makes it unlikely that you're going to catch a sudden change like high CPU usage
or an application filling all your ram. You may not care about that but I do.&lt;/p&gt;
&lt;p&gt;While I mentioned portability of top as an advantage, there is a catch to it:
the &lt;em&gt;tops&lt;/em&gt; in BSD and linux differ. The BSD one is based on the classic unix top
while the linux one is a reworked implementation. They aren't vastly different
but it does take some getting used to. Granted, it is possible to get the
classic top on linux but it's not available everywhere.&lt;/p&gt;
&lt;p&gt;An alternative to top has always been &lt;code&gt;htop&lt;/code&gt;. I myself have been a long time fan
of it over the classic top, and initially it was the only thing I used until I
started being concerned about portability. It has a very good color scheme by
default that shows mostly the same information as top but the colors allow it to
be interpreted with greater ease. But of the major BSDs I care about, OpenBSD
doesn't have it and it feels a bit &lt;em&gt;bolted on&lt;/em&gt; in places where it is present
(FreeBSD/NetBSD, and also OS X). So I consider it to be a Linux only feature.&lt;/p&gt;
&lt;p&gt;Another tools that I used constantly, is free paired with watch. Free gives a
nice overview of what is happening with your memory, how it is being used for
caching, how much is free and whether you are intensively using swap. Watch is
what makes free an interactie tool showing you changes. All you have to do is
open a terminal and run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;watch -n 1 free -m
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and you can monitor it, without using too much space (fits perfectly within a
small tmux pane). Both tools are part of the procps(-ng) package on linux.&lt;/p&gt;
&lt;p&gt;Now the last tool which I only most recently grew to appreciate is &lt;code&gt;vmstat&lt;/code&gt;.
Present on virtually all unices (I think) it shows all the vital system
information in tabular form. Perfect! It gives an overview of:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;processes&lt;/li&gt;
&lt;li&gt;memory&lt;/li&gt;
&lt;li&gt;swap&lt;/li&gt;
&lt;li&gt;disk I/O&lt;/li&gt;
&lt;li&gt;interrupts and context switches&lt;/li&gt;
&lt;li&gt;CPU split&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so in one word: everything. I use it with a repeat delay of 5 and in units of
megabyte:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;vmstat -S M 5
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and due to it's simplicity I think it will be my goto monitoring tool all my OSs
for a while.&lt;/p&gt;</summary></entry><entry><title>To BSD or not be</title><link href="//jepio.github.io/to-bsd-or-not-be.html" rel="alternate"></link><updated>2015-08-30T03:30:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-08-30:to-bsd-or-not-be.html</id><summary type="html">&lt;p&gt;I became interested in BSD's this week. The thought of installing one on my
hardware had been crawling around my head ever since someone told me their
"plan for the weekend is to install an original Unix while my girlfriend is
away".&lt;/p&gt;
&lt;p&gt;So I dived in and tried what I believe to be the 3 most popular and root
distributions: NetBSD, FreeBSD, OpenBSD. I cared about 3 things: support for
EFI booting, GPT, and WiFi.&lt;/p&gt;
&lt;p&gt;First I had to dig through lots of (what I consider to be) legacy information
about slices, wedges and (BSD) disklabels.&lt;/p&gt;
&lt;p&gt;FreeBSD has an EFI boot loader, supports GPT but the iwm module panic the
kernel about 80% of the time.&lt;/p&gt;
&lt;p&gt;NetBSD supports GPT, doesn't have an EFI bootloader and WiFi works 90% of the
time. Only sometimes does it decide to show me the middle finger.&lt;/p&gt;
&lt;p&gt;OpenBSD doesn't support GPT, nor EFI, and I can't test the WiFi because the
firmware needs to be downloaded after the install. Talk of planning right
there... Someone is working on EFI and GPT upstream which works in a virtual
machine, but I'm having problems installing it onto a real hard drive.&lt;/p&gt;
&lt;p&gt;Update:
So FreeBSD is still unusable due to the WiFi-related panics. NetBSD seems to
have decided that after initially working quite correctly with respect to the
WiFi, the wpa-supplicant is incorrect for it. So now on boot it stalls at the
WiFi configuration until I cancel. Since I don't have time to figure these
things out right now, I'll leave it for a better time.&lt;/p&gt;
&lt;p&gt;OpenBSD appears to work quite well if you ignore the not-obvious mechanics of
mixing &lt;strong&gt;experimental&lt;/strong&gt; GPT support with classic BSD disklabels. I made 1
OpenBSD partition and within that 4 labels: /, swap, /usr, /var. But when using
&lt;code&gt;disklabel&lt;/code&gt; it also showed me &lt;em&gt;some&lt;/em&gt; of the other partitions that I had on that
hard drive. Some, because I have 16 GPT partitions + the 4 OpenBSD ones and only
16 total are supported by disklabel.&lt;/p&gt;
&lt;p&gt;When it comes to booting I can boot FreeBSD using only their bootloader, fully in
EFI mode. NetBSD can be booted as a kernel from EFI grub. The only one that
can't be booted in EFI mode is OpenBSD. Although that is being worked on.&lt;/p&gt;
&lt;p&gt;On the bright side, all of the things I was testing are part of *BSD-CURRENT.
This goes especially for the iwm module used by my Intel 7260 chip. It was first
introduced to OpenBSD, then NetBSD copied it and finally it made it's way into
FreeBSD. So hopefully once the rough edges are ironed out things will be up to
this years par some time next year (or in November in the case of OpenBSD). I'll
definitely keep tracking the progress, but for now I'll experiment with FreeBSD
in a VM.&lt;/p&gt;</summary></entry><entry><title>The actual source of the bad battery life rumour surrounding linux</title><link href="//jepio.github.io/the-actual-source-of-the-bad-battery-life-rumour-surrounding-linux.html" rel="alternate"></link><updated>2015-08-23T19:48:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-08-23:the-actual-source-of-the-bad-battery-life-rumour-surrounding-linux.html</id><summary type="html">&lt;p&gt;This one is pretty widespread and gets repeated a lot:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;I don't use Linux because the battery life is worse than under Windows&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Here's what I have to say about this.&lt;/p&gt;
&lt;p&gt;My laptop is a Haswell machine. I say Haswell, because that's not only the
processor generation right there - it's also the chipset, DRAM controller
and GPU. What that means is that everything works together as a &lt;em&gt;package&lt;/em&gt;
to deliver the lowest power usage possible. And it does that quite well -
most of the time. &lt;/p&gt;
&lt;p&gt;The kernel itself is pretty good with handling battery life. All tweaks
that can be made are built into the kernel and can be modified through
either the proc or sys filesystems. Some of them are activated by default -
like CPU scaling. Others are best left in the hands of a tool that can
change the settings based on whether external power is connected - I used
to be a &lt;a href="https://www.samwel.tk/laptop_mode/"&gt;Laptop Mode Tools&lt;/a&gt; guy but lately I have turned to &lt;a href="https://linrunner.de/en/tlp/docs/tlp-linux-advanced-power-management.html"&gt;TLP&lt;/a&gt;
(since I have a Thinkpad). TLP requires a little less tweaking but both do
the same thing. I have also heard of jupiter and pm-utils but the former is
(from what I heard) dead and the latter I have not investigated.&lt;/p&gt;
&lt;p&gt;The ultimate tool that every laptop user should have running almost
constantly is &lt;a href="https://01.org/powertop"&gt;PowerTop&lt;/a&gt;. As the name suggests, it's a top-like
program for displaying power drain. Originally written by Intel, it's
probably best suited for use with their hardware but most of the
functionality should work with AMD processors as well. PowerTop has a
tabbed ncurses interface and shows the following information:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;summary screen with power estimate by process along with a 
  wakeup-per-second count - kill high wake-up applications&lt;/li&gt;
&lt;li&gt;package/core/gpu power state view - tells you if your hardware is
  sitting in the lowest power states enough.&lt;/li&gt;
&lt;li&gt;processor frequency breakdown - allows you to notice when your
  hardware is not down-clocking enough.&lt;/li&gt;
&lt;li&gt;per device power usage estimates - the precision is suspicious but if
  a device is draining a lot of power maybe it's best to disconnect it.&lt;/li&gt;
&lt;li&gt;tunables - tune the most common system settings.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;The first four have helped me multiple times to name a few. They allow me to
identify when an application is responsible for more power usage than I
would have expected. When a kernel bug stopped my laptop from reaching
package power states lower than PC2, I could find that out and reboot
instead of wasting power. When something strange had set my min and max
processor frequencies to 100%, I had the chance to notice and fix that.
My bluetooth was turning on after being blocked on every resume, and I saw
that through the device stats tab. So if you care at all about power usage,
PowerTop is your friend.&lt;/p&gt;
&lt;p&gt;Thanks to this utility I can also give some numbers to back up my claims of
&lt;em&gt;good&lt;/em&gt; Linux battery life. When my laptop idles with the screen off it uses
around 4 W. When watching a movie I have seen constant power drain of 6.5
W, thanks to &lt;strong&gt;hardware accelerated decoding&lt;/strong&gt;. I'll come back to this
later. Normal usage email, web, some text editing keeps me at between 7 and 9 W.
I consider all of these values, especially the movie watching usage, to be
very good.&lt;/p&gt;
&lt;p&gt;The only thing that really kills Linux laptops is flash. Or the lack
thereof. Flash is everywhere on the web (still) even though it has had
countless security advisories to prove it should be killed a long time ago.
What's more, the Linux version from Adobe does not get new features and is
only eligible for security updates. This means it does not have hardware
acceleration like the windows version, which leads to &lt;strong&gt;insane&lt;/strong&gt; power
usage. And by insane I mean 12-15 W are not unusual. This effectively cuts
my battery life in half. The real killer here is youtube. While google is
moving it away from flash towards HTML5, the HTML5 does not make it any
better. Chrome does not use acceleration on Linux, and Firefox is not ready
for it by default either (even with gstreamer it does not work particularly
well for me). The adobe alternatives - lightspark, gnash - did not show
better results when I tested them.&lt;/p&gt;
&lt;p&gt;So for me the conclusion is easy - if you want battery life, don't use
youtube. Or rather, don't use youtube in your browser. I have had much
better results with listening to youtube music through mps-youtube, a
python program for streaming from youtube from the command line. But aside 
from that I am satisfied with my laptop's performance. We have come a long
way and the next objective should be to accelerate HTML5 on the web. Of course
distributions should also pay extra attention to this aspect and enable many 
power saving settings by default.&lt;/p&gt;</summary></entry><entry><title>More useful commands for terminal job management</title><link href="//jepio.github.io/more-useful-commands-for-terminal-job-management.html" rel="alternate"></link><updated>2015-08-15T00:30:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-08-15:more-useful-commands-for-terminal-job-management.html</id><summary type="html">&lt;p&gt;fg/bg/jobs is for jobs within a terminal&lt;/p&gt;
&lt;p&gt;w to quickly show your terminals (that's a new one i didn't know before)
who/whoami? useless now.&lt;/p&gt;</summary></entry><entry><title>Command line clipboard managment</title><link href="//jepio.github.io/command-line-clipboard-managment.html" rel="alternate"></link><updated>2015-07-04T17:19:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-07-04:command-line-clipboard-managment.html</id><summary type="html">&lt;p&gt;I can't believe how awesome this is, it's the greatest thing to happen to me
since I got a laptop with a physical middle button which finally made separating
the CLIPBOARD-SELECTION buffer feasible. It's &lt;code&gt;xsel&lt;/code&gt;!&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;xsel -b &amp;lt; file.in
xsel -b &amp;gt; file.out
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;and more, can be found in &lt;code&gt;man xsel&lt;/code&gt;. It's awesome.&lt;/p&gt;</summary></entry><entry><title>Pipe buffer in vim</title><link href="//jepio.github.io/pipe-buffer-in-vim.html" rel="alternate"></link><updated>2015-06-10T01:25:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-06-10:pipe-buffer-in-vim.html</id><summary type="html">&lt;p&gt;You can use &lt;code&gt;%!&lt;/code&gt; to pipe a buffer through a unix command.&lt;/p&gt;</summary></entry><entry><title>Yet another vim feature I didn't know about</title><link href="//jepio.github.io/yet-another-vim-feature-i-didnt-know-about.html" rel="alternate"></link><updated>2015-06-01T01:27:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-06-01:yet-another-vim-feature-i-didnt-know-about.html</id><summary type="html">&lt;p&gt;As I was editting a python script this morning, I acidentally entered &lt;code&gt;K&lt;/code&gt; in
normal mode. Vim quickly hid and revelead a shell which contained two lines:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;no Python documentation found for 'd'&lt;/p&gt;
&lt;p&gt;Press ENTER or type command to continue&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;What is this sorcery&lt;/em&gt;, I thought to myself. I quickly googled but couldn't
quite find an answer. Then I remembered vim's built-in help system and it
revealed the following:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;K&lt;/p&gt;
&lt;p&gt;Run a program to lookup the keyword under the cursor.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Cool, ain't it? It uses the program specified by the variable &lt;code&gt;keywordprg&lt;/code&gt;, the
default is &lt;code&gt;man -s&lt;/code&gt; but for python files it changes to &lt;code&gt;pydoc&lt;/code&gt;. That's something
worth remembering.&lt;/p&gt;</summary></entry><entry><title>Windows... blows?</title><link href="//jepio.github.io/windows-blows.html" rel="alternate"></link><updated>2015-05-29T22:31:00+02:00</updated><author><name>Jepio</name></author><id>tag:jepio.github.io,2015-05-29:windows-blows.html</id><summary type="html">&lt;p&gt;I'm not usually a hater against Windows but this time I feel it's time to
speak up. I wanted to install Windows 8 on my new laptop, but since it doesn't
have a CD/DVD drive (and I wouldn't want it) I wanted to load the ISO onto a USB
stick to install from. Now I didn't have a USB stick until last week when I went
to the store to buy one. As I was looking at the shelves in Saturn I was sure I
wanted a USB 3.0 pendrive with the greatest possible read/write speeds.&lt;/p&gt;
&lt;p&gt;So I bought a Sandisk pendrive and was happy with my choice until today. That's
not to say I'm not, because it has everything I hoped for. The problem lies in
Windows. You see, it's not possible to install Windows from a USB 3.0 pendrive
since that requires drivers. And to load these drivers I would need a USB 2.0
stick. Aaaaargh!&lt;/p&gt;
&lt;p&gt;I actually think this has something to do with licensing. Microsoft can't bundle
vendor USB 3.0 drivers and it doesn't want to (can't?) include the open source
ones. So here I am, stuck with a nice USB 3.0 pendrive with Windows 8 on it,
able to boot from it in UEFI mode but not being able to install because once the
boot process ends the installer doesn't have access to the drive.&lt;/p&gt;
&lt;p&gt;Seems I'll have to borrow an older pendrive from someone. Oh well.&lt;/p&gt;</summary></entry></feed>